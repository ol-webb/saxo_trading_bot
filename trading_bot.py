from dotenv import load_dotenv
import os
import sqlite3
import pandas as pd
import numpy as np
import math
import sys
import requests
from pathlib import Path
from typing import Optional
from alpaca.trading.client import TradingClient
from alpaca.trading.requests import GetOrdersRequest
from alpaca.trading.enums import QueryOrderStatus
from alpaca.trading.requests import MarketOrderRequest, LimitOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce
from alpaca.data.historical.stock import StockHistoricalDataClient
from alpaca.data.requests import (
    StockSnapshotRequest,
    StockLatestTradeRequest,
    StockLatestQuoteRequest,
    StockBarsRequest,
)
from alpaca.data.enums import DataFeed
from alpaca.data.timeframe import TimeFrame
from datetime import datetime, timedelta, timezone
import time



# Add private directory to Python path (parent of core_logic package)
private_path = Path(__file__).resolve().parents[1] / "private"
sys.path.insert(0, str(private_path))

from core_logic import SignalEngine
from core_logic.paths import LIVE_DATABASE_PATH
from core_logic.config import ALPACA_KEY, ALPACA_SECRET




"""
This trading bot uses Alpaca to place trades.

The bot is relatively generalisable and functions as follows:

- A single table is used to store assets we are interested in trading.

- Assets have two principle features which determine the decisions we make:

    1. <signal>:            Boolean,   True if we should buy, False if we should sell.
    2. <position_state>:    String,    Collates all information about orders and holdings.

- signal is generated by a private model, although any strategy which can condense into a boolean can be substituted in.

- position_state summarises all possible order and holdings combinations for an asset; possibilities described below.
- NB that this is primarily a long only bot, so short positions are quickly closed if they happen to occur.

- Based entirely off signal and position_state, we can determine whether we should buy, sell, or hold an asset.

POSITION STATE:
_______________________________________
|ORDERS? | HOLDINGS? | POSITION STATE |
|--------|-----------|----------------|
|  NONE  |   NONE    |     CLOSED     |
|--------|-----------|----------------|
|  NONE  |   LONG    |      OPEN      |
|--------|-----------|----------------|
|  NONE  |   SHORT   |     ERROR*     |
|--------|-----------|----------------|
|  LONG  |   NONE    |    OPENING     |
|--------|-----------|----------------|
|  LONG  |   LONG    |  PARTIAL FILL  |
|--------|-----------|----------------|
|  LONG  |   SHORT   |   ERROR FIX*   |
|--------|-----------|----------------|
|  SHORT |   NONE    |     ERROR*     |
|--------|-----------|----------------|
|  SHORT |   LONG    |    CLOSING     |
|--------|-----------|----------------|
|  SHORT |   SHORT   |     ERROR*     |
|--------|-----------|----------------|

- ERRORS*: these should not occur, but could in the case of delayed / unfilled orders, or other unexpected behaviour.
- In these cases, the bot will correct orders and holdings
- There could be cases where we have multiple orders on both sides - depending on the nature of the orders, these can cancel eachother. Otherwise we reconcile cases where we have multiple orders on both sides.


"""
class TradingBot:

    def __init__(self, thresholds=None, buy_quantity=100, paper=True):

        self.signalengine = SignalEngine(refresh_rate=10, thresholds=thresholds)
        self.database_path = LIVE_DATABASE_PATH
        self.buy_quantity = buy_quantity
        self.paper = paper
    
    # ======================= #
    # Refresh Holdings Table  #
    # ======================= #
    def refresh_holdings_table_signals(self):
        self.signalengine.run_holdings_engine_refresh()

    # use asset price and buy quantity to calculate the number of shares to buy
    def get_order_size_quantity(self, ticker):
        """order sizing, it is possible to do fractional trading on some occasions, although we will not do this"""

        # check if the asset is tradable and fractionable
        trading = TradingClient(ALPACA_KEY, ALPACA_SECRET, paper=self.paper)
        asset = trading.get_asset(ticker)
        syb = asset.symbol
        tradable = asset.tradable
        fractionable = asset.fractionable

        if not tradable:
            print(f"Asset {ticker} is not tradable")
            return None
        
        price = self.get_asset_price(ticker)
        print(f"Price for {ticker} is {price}")
        if price is None:
            print(f"Price for {ticker} is None")
            return 1

        shares = self.buy_quantity / price # shares to buy = buy quantity / price per share

        # if its not fractionable we need to round, if it is, just return as is
        if fractionable:
            return shares
        else:
            return int(math.ceil(shares))


    # ======================= #
    #     ALPACA METHODS      #
    # ======================= #

    def get_asset_price(self,ticker: str):
        """
        Returns a ballpark last price for `ticker` (float) or None if unavailable.
        - Prefers consolidated (15-min delayed) data for coverage on illiquid names.
        - Falls back to IEX real-time, then to a recent minute bar.
        Requires ALPACA_KEY and ALPACA_SECRET to be available in scope.
        """

        sym = (ticker or "").upper().strip()
        if not sym:
            return None

        try:
            client = StockHistoricalDataClient(ALPACA_KEY, ALPACA_SECRET)
        except Exception:
            return None

        # Snapshot (fast path)
        try:
            snap = client.get_stock_snapshot(StockSnapshotRequest(symbol_or_symbols=sym))
            ss = snap.get(sym) or (next(iter(snap.values())) if snap else None)
            if ss:
                if getattr(ss, "latest_trade", None) and ss.latest_trade.price is not None:
                    return float(ss.latest_trade.price)
                if getattr(ss, "latest_quote", None):
                    bid = ss.latest_quote.bid_price
                    ask = ss.latest_quote.ask_price
                    if bid is not None and ask is not None:
                        return float((bid + ask) / 2)
                if getattr(ss, "minute_bar", None) and ss.minute_bar.close is not None:
                    return float(ss.minute_bar.close)
        except Exception:
            pass  # move to explicit feed fallbacks

        # Latest trade/quote with explicit feeds
        for feed in (DataFeed.DELAYED_SIP, DataFeed.IEX):
            # latest trade
            try:
                lt = client.get_stock_latest_trade(
                    StockLatestTradeRequest(symbol_or_symbols=sym, feed=feed)
                )
                t = lt.get(sym)
                if t and t.price is not None:
                    return float(t.price)
            except Exception:
                pass
            # latest quote → mid
            try:
                lq = client.get_stock_latest_quote(
                    StockLatestQuoteRequest(symbol_or_symbols=sym, feed=feed)
                )
                q = lq.get(sym)
                if q and q.bid_price is not None and q.ask_price is not None:
                    return float((q.bid_price + q.ask_price) / 2)
            except Exception:
                pass

        # Recent minute bar (≥15 min old → consolidated free on Basic)
        try:
            end = datetime.now(timezone.utc) - timedelta(minutes=16)
            bars = client.get_stock_bars(
                StockBarsRequest(
                    symbol_or_symbols=sym,
                    timeframe=TimeFrame.Minute,
                    start=end - timedelta(hours=1),
                    end=end,
                    limit=1,
                )
            )
            b = bars.get(sym)
            if b:
                return float(b[0].close)
        except Exception:
            pass

        return None


    def get_all_open_orders(self):
        trading_client = TradingClient(ALPACA_KEY, ALPACA_SECRET, paper=self.paper)

        get_orders_data = GetOrdersRequest(
            status=QueryOrderStatus.OPEN,
            limit=200,
            nested=True
        )

        orders = trading_client.get_orders(filter=get_orders_data)
        return orders


    def get_asset_pending_orders(self, orders, ticker):
        
        for order in orders:

            if order.symbol == ticker:

                qty = order.qty
                side = order.side._value_
                orderid = str(order.id)
                return side, qty, orderid
        return None, None, None


    def get_asset_positions(self, ticker):

        trading_client = TradingClient(ALPACA_KEY, ALPACA_SECRET, paper=self.paper)

        try:
            position = trading_client.get_open_position(ticker)
        except Exception as e:
            print(f"Error getting asset positions: {e}")
            return None, None

        side = position.side._value_ # 'long' or 'short
        qty = position.qty

        return side, qty


    def place_market_order(self, *, ticker, side, quantity=None):
        """
        We use DAY orders, since GTC is not accepted for fractional quantities

        caveat with day orders: if the order is placed after market close, it will be cancelled at end of day
        however, if the signal remains BUY, then the order will be placed again.
        in short: there will be some cases where orders are closed, but they will be re-placed after closed.
        """ 

        trading_client = TradingClient(ALPACA_KEY, ALPACA_SECRET, paper=self.paper)

        if side == 'buy':
            s = OrderSide.BUY
        elif side == 'sell':
            s = OrderSide.SELL
        else:
            raise ValueError(f"Invalid side: {side}")

        # if quantity is provided -> we are selling existing position and must use the provided quantity
        if quantity is None:
            quantity = self.get_order_size_quantity(ticker)
        else:
            quantity = quantity

        print(f"Quantity for {ticker} is {quantity}")

        market_order_data = MarketOrderRequest(
                    symbol=ticker,
                    qty=quantity,
                    side=s,
                    time_in_force=TimeInForce.DAY
                    )

        order = trading_client.submit_order(
            order_data=market_order_data
        )
        return order


    def cancel_order(self, ticker):

        # first get open orders and the order id for that asset
        # performance wise, not best to call all open orders, but we likely wont cancel orders often
        orders = self.get_all_open_orders()
        side, qty, orderid  = self.get_asset_pending_orders(orders, ticker)

        trading_client = TradingClient(ALPACA_KEY, ALPACA_SECRET, paper=self.paper)
        trading_client.cancel_order_by_id(order_id = orderid)


    # ======================= #
    # UPDATE POSITION STATES  #
    # ======================= #

    def get_new_asset_position_state(self, ticker, orders):
        """calls get_pending_orders and get_open_positions, and returns a new position state"""

        order_side, oq, orderid = self.get_asset_pending_orders(orders, ticker)
        if oq is not None:
            order_qty = float(oq)
        else:
            order_qty = 0
        print(order_side, order_qty) # order side: 'buy' or 'sell' or None

        holdings_side, hq = self.get_asset_positions(ticker)
        if hq is not None:
            holdings_qty = float(hq)
        else:
            holdings_qty = 0
        print(holdings_side, holdings_qty)


        if (holdings_side == 'long') and (holdings_qty > 0):

            if (order_side == 'buy') and (order_qty > 0):
                return "PARTIAL FILL", holdings_qty

            elif (order_side == None) and ((order_qty == None) or (order_qty == 0)):
                return "OPEN", holdings_qty

            elif (order_side == 'sell') and (order_qty > 0): # still positive for shorting
                return "CLOSING", holdings_qty

        elif (holdings_side == None) and ((holdings_qty == None) or (holdings_qty == 0)):

            if (order_side == 'buy') and (order_qty > 0):
                return "OPENING", holdings_qty

            elif (order_side == None) and ((order_qty == None) or (order_qty == 0)):
                return "CLOSED", holdings_qty

            elif (order_side == 'sell') and (order_qty > 0):
                return "SHORTING", holdings_qty

        elif (holdings_side == 'short') and (holdings_qty < 0): # should this be negative?

            if (order_side == 'buy') and (order_qty > 0):
                return "FIXING_SHORT", holdings_qty
            
            elif (order_side == None) and ((order_qty == None) or (order_qty == 0)):
                return "SHORT_OPEN", holdings_qty

            elif (order_side == 'sell') and (order_qty > 0):
                return "MORE_SHORTING", holdings_qty

        else:
            return "ERROR", holdings_qty
        

    def refresh_holdings_table_position_states(self):
        """refresh the position states for all assets in the holdings table"""

        con = sqlite3.connect(self.database_path)
        df = pd.read_sql_query("SELECT * FROM holdings", con)
        con.close()

        orders = self.get_all_open_orders()

        unique_tickers = df['cik_ticker'].unique()

        # for ticker in unique_tickers:
        #     position_state, holdings_qty = self.get_new_asset_position_state(ticker, orders)
        #     df.loc[df['cik_ticker'] == ticker, 'position_state'] = position_state
        #     df.loc[df['cik_ticker'] == ticker, 'quantity_bought'] = holdings_qty

        for index, row in df.iterrows():
            ticker = row['cik_ticker']
            print(ticker)
            position_state, holdings_qty = self.get_new_asset_position_state(ticker, orders)
            df.loc[index, 'position_state'] = position_state
            df.loc[index, 'quantity_bought'] = holdings_qty

        updated_data = [
            (row['position_state'], row['quantity_bought'], row['unique_id']) for _, row in df.iterrows()
        ]

        con = sqlite3.connect(self.database_path)
        cursor = con.cursor()
        cursor.executemany("""
                            UPDATE holdings
                            SET position_state = ?, quantity_bought = ?
                            WHERE unique_id = ?
                            """, updated_data)
        con.commit()
        con.close()

        print("Position states refreshed")



    # =============================== #
    #  RECONCILE ORDERS AND HOLDINGS  #
    # =============================== #
    #  After refreshing position states and signals, as above
    #  these methods place relevant orders to sync position state + signal

    def compile_asset_signals(self, array):
        """occasionally, assets might have multiple rows in holdings, with differing signals, this function compiles them into a single signal"""

        if "SELL" in array:
            return "SELL"
        elif "BUY" in array:
            return "BUY"
        else:
            return "HOLD"


    def reconcile_asset_orders_and_holdings(self, ticker):

        con = sqlite3.connect(self.database_path)
        df = pd.read_sql_query("SELECT * FROM holdings", con)
        con.close()

        try:
            row = df[df['cik_ticker'] == ticker]
            position_state = row['position_state'].values[0]
            signal_array_values = row['signal'].values
            signal = self.compile_asset_signals(signal_array_values)
            #print(f"testing signal compiler \n signal array values: {signal_array_values} \n signal compiled: {signal}")
            quantity_bought = row['quantity_bought'].values[0]
        except Exception as e:
            print(f"Error in extracting data for {ticker}")
            return

        if signal == 'BUY':

            if position_state in ['OPEN', 'OPENING', 'PARTIAL FILL', 'FIXING_SHORT']:
                return
            elif position_state == 'CLOSED':
                self.place_market_order(ticker = ticker, side = 'buy', quantity = None)
            elif position_state == 'CLOSING':
                self.cancel_order(ticker)
                self.place_market_order(ticker = ticker, side = 'buy', quantity = None)
            elif position_state == 'ERROR':
                print(f"Error in reconcile_asset_orders_and_holdings for {ticker}")
                return

        elif signal == 'HOLD':

            if position_state in ['OPEN', 'CLOSED', 'FIXING_SHORT']:
                return
            elif position_state in ['OPENING', 'PARTIAL FILL']:
                self.cancel_order(ticker)
            elif position_state == 'CLOSING':
                self.cancel_order(ticker)
            elif position_state == 'ERROR':
                print(f"Error in reconcile_asset_orders_and_holdings for {ticker}")
                return
            
        elif signal == 'SELL':

            if position_state in ['CLOSED', 'CLOSING', 'FIXING_SHORT']:
                return
            elif position_state == 'OPEN':
                self.place_market_order(ticker = ticker, side = 'sell', quantity = quantity_bought)
            elif position_state == 'OPENING':
                self.cancel_order(ticker)
            elif position_state == 'PARTIAL FILL':
                self.cancel_order(ticker)
                self.place_market_order(ticker = ticker, side = 'sell', quantity = quantity_bought)
            elif position_state == 'ERROR':
                print(f"Error in reconcile_asset_orders_and_holdings for {ticker}")
                return
        
        else:
            print(f"Error in reconcile_asset_orders_and_holdings for {ticker}")
            return


    def reconcile_table_orders_and_holdings(self):
        """
        Iterate through whole table and reconcile position state + signal for each asset"""

        con = sqlite3.connect(self.database_path)
        df = pd.read_sql_query("SELECT * FROM holdings", con)
        con.close()

        unique_tickers = df['cik_ticker'].unique()

        for ticker in unique_tickers:
            # buy_quantity = df.loc[df['cik_ticker'] == ticker, 'quantity_bought'].values[0]
            # print(ticker, buy_quantity)
            buy_quantity = next(iter(df.loc[df['cik_ticker'] == ticker, 'quantity_bought']), None)
            print(ticker, buy_quantity)
            self.reconcile_asset_orders_and_holdings(ticker)

        # for index, row in df.iterrows():
        #     ticker = row['cik_ticker']
        #     buy_quantity = row['quantity_bought']
        #     print(ticker, buy_quantity)
        #     self.reconcile_asset_orders_and_holdings(ticker)


    # ======================= #
    #    MAIN LOOP METHODS    #

    def main_loop(self):
        """
        MAIN LOOP FOR BOT

        1. Using seperate signal engine, refresh holdings table signals
        2. Refresh position states
        3. Reconcile orders and holdings
        4. Sleep for 5 minutes
        5. Repeat
        """


        self.signalengine.run_section_one()
        self.signalengine.run_holdings_engine_refresh()
        self.refresh_holdings_table_position_states()
        self.reconcile_table_orders_and_holdings()

        time.sleep(300)
